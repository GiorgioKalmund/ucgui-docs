"use strict";(globalThis.webpackChunkucgui_docs=globalThis.webpackChunkucgui_docs||[]).push([[7587],{403:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/tutorial-creating-ii-image-button-b1aece5ce2c9470992d58b82ffb3580c.png"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(6540);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}},9935:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"getting-started/tutorial/tutorial-creating-2","title":"Tutorial - Advanced Drawing","description":"Now that we have learnt how to draw a basic \'Hello, World!\' to the screen using UCGUI,","source":"@site/docs/getting-started/tutorial/tutorial-creating-2.md","sourceDirName":"getting-started/tutorial","slug":"/getting-started/tutorial/tutorial-creating-2","permalink":"/ucgui-docs/docs/getting-started/tutorial/tutorial-creating-2","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Tutorial - Advanced Drawing"},"sidebar":"docs","previous":{"title":"Tutorial - Drawing to the Screen","permalink":"/ucgui-docs/docs/getting-started/tutorial/tutorial-creating"},"next":{"title":"Quickstart","permalink":"/ucgui-docs/docs/getting-started/quickstart"}}');var i=n(4848),a=n(8453);const s={sidebar_position:4,title:"Tutorial - Advanced Drawing"},r=void 0,l={},c=[{value:"Custom Components",id:"custom-components",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Now that we have learnt how to draw a basic 'Hello, World!' to the screen using UCGUI,\nlet's take a look at some more complex scenes."}),"\n",(0,i.jsx)(t.p,{children:"In addition to the 'UI.Text(...)' initializers the 'UI' class also holds initiliazers for almost\nall native components in UCGUI."}),"\n",(0,i.jsx)(t.p,{children:"Let's re-use the screen from before and add some more elements to our interface."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'public override void Create(){\n    UI.Image(Color.purple)\n    .Maximize()\n    .Parent(canvas);\n\n    UI.Text("Hello, World!")\n    .FitToContents()\n    .Color(Color.white)\n    .Bold()\n    .Parent(canvas);\n\n    UI.Button("Press Me", () => {\n        // ... action on press\n    }).OffsetY(-150).Parent(canvas);\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Image and Button",src:n(403).A+"",width:"1696",height:"944"})}),"\n",(0,i.jsx)(t.p,{children:"This example introduces a couple of new concepts: Images and Buttons."}),"\n",(0,i.jsxs)(t.p,{children:["An image is essentially just a glorified wrapper around Unity's built in Image component. You can change sprite, color etc.\nvia UCGUI but thats mostly it. The ",(0,i.jsx)(t.code,{children:"UI.Image(...)"})," initializer accepts a Texture2D, a Sprite or even just a color; like in the example above.\nIn combination with the ",(0,i.jsx)(t.code,{children:"Maximize()"})," call, which stretches a given component to completely fill its parent's rect, this makes for a quick\nand dirty solution for a background color. As the image in our example is parented to the canvas it conveniently fills the\nentirety of the screen's background in our desired color."]}),"\n",(0,i.jsx)(t.admonition,{title:"important",type:"tip",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"The order of parenting components determines the hierarchial layering order."}),"\nTo create a background we thus need to parent it to the canvas first, allowing all following elements parented\nto the same component (here: the 'canvas') to be layered ",(0,i.jsx)(t.strong,{children:"on top"})," of the image."]})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"UI.Button(...)"})," creates a button with some text and a handler to inject press functionality.\nThere are multiple initializers for a button, but this is a simple way of creating a button for now."]}),"\n",(0,i.jsx)(t.h3,{id:"custom-components",children:"Custom Components"}),"\n",(0,i.jsxs)(t.p,{children:["You might want to build fully custom components with custom functionalities. The possibilities are endless here\nand your imagination is the only thing holding you back (",(0,i.jsx)(t.em,{children:"and maybe some bugs from my end or Unity's layout system. I still not quite sure\nhow something can be as bad as the Horizontal- and VerticalLayoutGroup MonoBehaviours"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["I have created a mini example, showcasing the basic flow of how one would set up such a component.\nIt is probably most helpful however to simply take a look at the implementation of UCGUIs components directly.\nIf you are ever unsure of how a certain component achieves something you can just ",(0,i.jsx)(t.code,{children:"Ctrl + Left"})," onto the class name to\ngo to the class' definition and implementation."]}),"\n",(0,i.jsx)(t.p,{children:"Here a small example for a custom component."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class MyComponent : BaseComponent {\n    \n    private bool _isCool = false;\n\n    public MyComponent SetCool(bool c){\n        _isCool = c;\n        return this;\n    }\n\n    public void Start(){\n        if (_isCool){\n            // ...\n        }\n    }\n\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Even though small this example shows a lot about the inner workings of UCGUI."}),"\n",(0,i.jsxs)(t.p,{children:["First of all, all components share a common ancestor: the ",(0,i.jsx)(t.code,{children:"BaseComponent"}),". Think of it like\nthe MonoBehaviour equivalent for UCGUI. Every new script or component you might want to\nadd will eventually inherit from it, one way or another."]}),"\n",(0,i.jsx)(t.p,{children:"Second, we can observer the fluent pattern in action. It is actually quite trivial to implement, just\nmake the return type your own class name and return yourself after you have completed the functions desired\ncomputation."}),"\n",(0,i.jsxs)(t.admonition,{title:"important",type:"warning",children:[(0,i.jsxs)(t.p,{children:["One downfall of having the fluent pattern implemented like this is that polymorphism comes to bite you\nwhen you try ordering operations incorrectly. For example, if we now introduce a new component ",(0,i.jsx)(t.code,{children:"MyComponent2"}),",\nwhich inherits from ",(0,i.jsx)(t.code,{children:"MyComponent"}),", and also has a fluent-style function returning itself, we might run into some issues."]}),(0,i.jsxs)(t.p,{children:["When we create a new instance of our derived class it obviously has access both methods. Its new internal\none and ",(0,i.jsx)(t.code,{children:"SetCool"}),". However, ",(0,i.jsx)(t.strong,{children:"order of operations matter here"}),"! If you first call the new method and aferwards\n'SetCool' everything is fine, as derived returns derived --\x3e still has access to 'SetCool'.\nThe problem arises when we try to do it the other way around.\nIf the dervied class calls 'SetCool' first after instantiation, it will now\nbe cast to an instance of 'MyComponent', which no longer has access to the fluent call of the 'MyComponent2' class."]}),(0,i.jsx)(t.p,{children:"There are three ways to circumvent this:"}),(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Reorder your operations to be applied in order from most derived in the hierarchy to most generic."}),"\n",(0,i.jsxs)(t.li,{children:["Use the ",(0,i.jsx)(t.code,{children:".Cast<T>"})," extension to cast your component back down. (Make sure the cast is valid!)"]}),"\n",(0,i.jsxs)(t.li,{children:["Create a static extension class which offers the same functionalities for your derived classes but via generics, allowing the return\nvalues to never change type. This is actually how ",(0,i.jsx)(t.a,{href:"https://github.com/GiorgioKalmund/UCGUI/blob/main/Runtime/Components/Support/UI.cs",children:"UCGUI's UI class"})," does it."]}),"\n"]})]}),"\n",(0,i.jsx)(t.p,{children:"After this pretty long warning we can now ask ourselves, 'But how can I put my component onto the screen?'.\nThe static UI builders you have gotten to know until know are actually just wrappers around the real way of creating components in UCGUI:\nA generic instantiator."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",metastring:'title="Custom Component Instantiation"',children:"MyComponent myComponentInstance = UI.N<MyComponent>().SetCool(true).Parent(canvas);\n"})}),"\n",(0,i.jsx)(t.p,{children:"This generic instantiator is at the heart of UCGUI. Any class inheriting from 'BaseComponent' can be instantiated via this one method."}),"\n",(0,i.jsx)(t.p,{children:"Jumping back and taking a another look a the example higher up I want to highlight another oddity you might have realized.\nWhy are we using 'Start' and not 'Awake' here? A keen reader might already have an idea, as the related issue was already hinted\nat previously. The reason is quite simple:"}),"\n",(0,i.jsxs)(t.p,{children:["During the 'Awake' phase of your custom component (which you can ",(0,i.jsx)(t.code,{children:"override"})," from the BaseComponent, as it is marked ",(0,i.jsx)(t.code,{children:"virtual"}),") ",(0,i.jsx)(t.code,{children:"_isCool"})," has not yet been set to true.\nAll function calls after the instantiation using '.N<T>' will be executed ",(0,i.jsx)(t.strong,{children:"after Awake"}),". Thus, we can only read out the true\nvalue of '_isCool' during Start."]}),"\n",(0,i.jsx)(t.p,{children:"Again, a small recap of what we have learnt so far:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"UCGUI also has initiliazers for images, buttons and a bunch more components which can help you to build your UI"}),"\n",(0,i.jsx)(t.li,{children:"Different components have differnt functions to customize them, but they share some between all of them with\nthe help of a generic fluent pattern extension class"}),"\n",(0,i.jsx)(t.li,{children:"All UCGUI elements inherit from 'BaseComponent'"}),"\n",(0,i.jsx)(t.li,{children:"For inheritence within fluent-style contexts, order of operations can matter!"}),"\n",(0,i.jsx)(t.li,{children:"We have learnt how to define and instantiate fully custom components."}),"\n",(0,i.jsx)(t.li,{children:"We have learnt above the order of execution for functions on objects and why splitting some of your workload into 'Start' might be neccessary."}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{title:"horray!",type:"note",children:(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Thats it with the tutorial for now. If you have something in mind I'd suggest to try and start prototyping it with UCGUI and see how it goes. There\nare also some aspects and functionalities of UCGUI which have not been mentioned in this tutorial. Take a look at the individual docs pages of all components to get a more\nin depth and comprehensive overview!"})})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);