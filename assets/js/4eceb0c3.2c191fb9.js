"use strict";(globalThis.webpackChunkucgui_docs=globalThis.webpackChunkucgui_docs||[]).push([[3018],{2864:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/tutorial-creating-hello-world-simple-4fe119c93cdd679458c6710cc1506717.png"},3206:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/tutorial-creating-hello-world-improved-f997f6e20dc4ac4ace837d8e1ff9562c.png"},5997:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/tutorial/tutorial-creating","title":"Tutorial - Drawing to the Screen","description":"Now that we know a bit more about why UCGUI is the way it is you might be","source":"@site/docs/getting-started/tutorial/tutorial-creating.md","sourceDirName":"getting-started/tutorial","slug":"/getting-started/tutorial/tutorial-creating","permalink":"/ucgui-docs/docs/getting-started/tutorial/tutorial-creating","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Tutorial - Drawing to the Screen"},"sidebar":"docs","previous":{"title":"Tutorial - Basics","permalink":"/ucgui-docs/docs/getting-started/tutorial/tutorial-basics"},"next":{"title":"Tutorial - Advanced Drawing","permalink":"/ucgui-docs/docs/getting-started/tutorial/tutorial-creating-2"}}');var o=n(4848),r=n(8453);const s={sidebar_position:3,title:"Tutorial - Drawing to the Screen"},a=void 0,l={},c=[];function h(e){const t={admonition:"admonition",br:"br",code:"code",em:"em",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Now that we know a bit more about why UCGUI is the way it is you might be\nwondering ",(0,o.jsx)(t.em,{children:'"Ok cool, but how do I get a text or a button onto the screen? I know\nhow to do it via the editor and it is super fast so why would I even need\nthis stupid libary?"'}),". That's a fair point, so I will show you now:"]}),"\n",(0,o.jsxs)(t.p,{children:["UCGUI separates its UIs into so called ",(0,o.jsx)(t.strong,{children:"Screens"})," which are essentially just\na big content holder for all of your UI. Think of it like a mediation layer\nbetween the canvas in your editor and your UI code.\nInstead of creating an empty GameObject for every UI elements manually and then adding\nit to the correct spot in the hierarchy you create your components inside of such a screen."]}),"\n",(0,o.jsxs)(t.p,{children:["Let's create our first screen and add a 'Hello, World!' text to it. For that we need\na script which inherits from ",(0,o.jsx)(t.code,{children:"SimpleScreen"}),". Screens should be the ",(0,o.jsx)(t.strong,{children:"only"})," scripts\nwe actually assign and attach in the editor."]}),"\n",(0,o.jsxs)(t.p,{children:["First create a new MonoBehaviour script and name it 'MyScreen'.\nNext add ",(0,o.jsx)(t.strong,{children:"import UCGUI"})," and inherit from the SimpleScreen class like so:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"using UCGUI;\nusing UnityEngine;\n\npublic class MyScreen : SimpleScreen\n{\n    // ... \n}\n"})}),"\n",(0,o.jsxs)(t.admonition,{type:"important",children:[(0,o.jsxs)(t.p,{children:["Before we implement the missing methods attach this script to a (preferrably empty) GameObject in\nthe scene hierarchy which is ",(0,o.jsx)(t.strong,{children:"hierarchially below a Canvas"}),". If you don't have a canvas yet, please add\none. This is a ",(0,o.jsx)(t.strong,{children:"crucial step"})," and your UI will ",(0,o.jsx)(t.strong,{children:"not appear properly"})," if you have not\nset this up correctly."]}),(0,o.jsx)(t.p,{children:"Your hierarchy would then look something like this:"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:'language-title="Hierarchy',metastring:'Example"',children:"Scene Root\n\u2514\u2500 Canvas \n    \u2514\u2500 Empty :: MyScreen\n\u2514\u2500 ...\n"})})]}),"\n",(0,o.jsxs)(t.p,{children:["Your IDE or Unity might already alert you that SimpleScreen requires some\nmembers to be implemented.\nThese should be three different methods: ",(0,o.jsx)(t.code,{children:"Create"}),", ",(0,o.jsx)(t.code,{children:"Initialize"})," and ",(0,o.jsx)(t.code,{children:"GetCanvas"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"For our simple example we only need 'Create' and 'GetCanvas', you can simply leave\n'Initialize' empty."}),"\n",(0,o.jsx)(t.p,{children:"Now lets put 'Hello, World' onto the screen and I'll explain why and how this works afterwards."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'// ... class header ...\n\npublic override void Create(){\n    UI.Text("Hello, World!").Parent(canvas);\n}\n\n// ...\n\npublic override void GetCanvas(){\n    return gameObject.GetComponentInParent<Canvas>();\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The 'Create' method might seem pretty straight forward. You create a TextComponent which\ncontains the desired string and parent it to the ",(0,o.jsx)(t.code,{children:"canvas"})," reference. ",(0,o.jsx)(t.br,{}),"\n","However where does this reference come from? This is where 'GetCanvas' comes in.\n",(0,o.jsx)(t.strong,{children:"You decide"})," how to you want to return a valid canvas (if any), searching for it\nin the parent is not optimal but a quick and easy solution if you have set up the hierarchy correctly.\nThis method will initialize the 'canvas' member, allowing 'Create' to access it."]}),"\n",(0,o.jsx)(t.p,{children:"If you now go into Play Mode you should see your text get drawn onto the screen, looking\nsomething like this:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Hello World Simple",src:n(2864).A+"",width:"1502",height:"844"})}),"\n",(0,o.jsxs)(t.p,{children:["You might have already figured out that ",(0,o.jsx)(t.code,{children:"UI.Text(string)"})," is a static builder to create\na new GameObject with a TextComponent attached to it. ",(0,o.jsx)(t.br,{}),"\n","This isn't enough though, you also need to parent the element to some place in the hierarchy, otherwise it will have 'null' as a parent\nand it will be attached to the highest level of the scene hierarchy and not be visible.\n",(0,o.jsx)(t.code,{children:"Parent(...)"})," can be used to prevent this, which parents the element to a given position in the hierarchy.\nThis is why earlier we first had to define what 'canvas' actually is, so we can later use it\nin our 'Create' method. You can pass most objects into 'Parent', allowing you to create\nyour hierarchy this way. If you are inside of a screen and want the object to be bound\nto the screen rather than to the top level canvas, simple use the ",(0,o.jsx)(t.code,{children:"this"})," reference."]}),"\n",(0,o.jsxs)(t.p,{children:["You might also be thinking ",(0,o.jsx)(t.em,{children:'"Well this looks cool and all but the text is a bit small, it wraps weirdly\nand I want it to be bold..."'}),". Again, fair argument but UCGUI offers solutions to\nall of your problems (",(0,o.jsx)(t.em,{children:"at least for this UI example, not in real life :/"}),")."]}),"\n",(0,o.jsx)(t.p,{children:"This where the fluent pattern jumps in. UCGUI makes use of a generic extension class\nwhich allows all components to have certain shared function available to them. 'Parent'\nis one of them for example. However, some functions are also inside the classes themselves\nand thus limited to its instances."}),"\n",(0,o.jsx)(t.p,{children:"Let's expand on our previous example and address all of your hypothetical concerns:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'// ... \n\npublic override void Create(){\n    UI.Text("Hello, World!")\n    .FitToContents()\n    .FontSize(124)\n    .Bold()\n    .Parent(canvas);\n}\n\n// ...\n'})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Hello World Improved",src:n(3206).A+"",width:"1706",height:"952"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Ahhh"}),", much better! As you can see, the fluent pattern allows us to easily chain multiple\nstyling options without having to re-reference the object multiple times."]}),"\n",(0,o.jsxs)(t.p,{children:["Here ",(0,o.jsx)(t.code,{children:"FitToContents"}),", ",(0,o.jsx)(t.code,{children:"FontSize"})," and ",(0,o.jsx)(t.code,{children:"Bold"})," are TextComponent-specific, whereas\n'Parent' can be universally applied to any component."]}),"\n",(0,o.jsx)(t.p,{children:"'FitToContents' simply tells the rect of the text to adapt to the preferred\nsize of the text itself, removing our weird line-wrap issues from before.\n'FontSize' and 'Bold' should be self-explanatory."}),"\n",(0,o.jsx)(t.p,{children:"Perfect. Now we know how to display some basic UI to the screen!\nA small recap of what we have learnt so far:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Screens server as a mediation layer between the editor and your UCGUI interface and can be initialized with a reference to the parent canvas."}),"\n",(0,o.jsx)(t.li,{children:"UCGUI uses the fluent pattern for almost all of the configuration of components, allowing for quick and simple modifications."}),"\n",(0,o.jsxs)(t.li,{children:["The static ",(0,o.jsx)(t.code,{children:"UI"})," class offers a lot of preset builders, like 'UI.Text(...)', for quick creation of UCGUI's default components."]}),"\n",(0,o.jsxs)(t.li,{children:["Setting the parent for any component is ",(0,o.jsx)(t.strong,{children:"crucial"}),"! Do not forget it."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(6540);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);